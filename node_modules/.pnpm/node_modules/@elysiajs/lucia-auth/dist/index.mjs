// src/index.ts
import { Elysia as Elysia2 } from "elysia";
import { lucia } from "lucia";
import {
  auth0,
  apple,
  azureAD,
  box,
  discord,
  dropbox,
  facebook,
  github,
  gitlab,
  google,
  lichess,
  line,
  linkedIn,
  osu,
  patreon,
  reddit,
  salesforce,
  slack,
  spotify,
  twitch,
  twitter
} from "@lucia-auth/oauth/providers";

// src/utils.ts
import { Elysia } from "elysia";
var createOAuth = (auth, createProvider, name, sessionName, defaultCreateUser) => (config) => {
  const {
    path = `/${name}`,
    callback = `/${name}/callback`,
    createUser: createNewUser = defaultCreateUser,
    hook: _hook = {},
    cookie,
    ...init
  } = config;
  const hook = _hook;
  const provider = createProvider(auth, init);
  return new Elysia({
    name: `@elysiajs/lucia-auth/${name}`,
    seed: config
  }).get(
    path,
    async function oauthRequest({ cookie: { oauthState }, redirect }) {
      const [url, state] = await provider.getAuthorizationUrl();
      oauthState.value = state;
      oauthState.set({
        path: "/",
        sameSite: true,
        httpOnly: true,
        maxAge: 3600
      });
      return redirect(url.toString());
    },
    hook.redirect
  ).get(
    callback,
    async function oauthCallback({
      set,
      query,
      query: { code, state },
      cookie: cookie2,
      cookie: { oauthState }
    }) {
      if (state !== oauthState.value)
        throw new Error("Invalid state");
      const callback2 = await provider.validateCallback(
        code
      );
      const { getExistingUser, createUser, createKey } = callback2;
      const userData = callback2[`${name}User`];
      const handleCreateUser = async () => {
        const { id, ...attributes } = (
          // @ts-ignore
          await createNewUser(userData)
        );
        await createUser({
          // @ts-ignore
          id,
          attributes
        });
        return {
          userId: id,
          ...attributes
        };
      };
      const user = await getExistingUser() ?? await handleCreateUser();
      if (!user?.userId)
        return set.status = "Internal Server Error";
      const { sessionId } = await auth.createSession({
        userId: user.userId,
        attributes: {}
      });
      cookie2[sessionName].value = sessionId;
      oauthState.remove();
      return userData;
    },
    // @ts-ignore
    hook.callback
  );
};
var createOAuthWithPKCE = (auth, createProvider, name, sessionName, defaultCreateUser) => (config) => {
  const {
    path = `/${name}`,
    callback = `/${name}/callback`,
    hook = {},
    createUser: createNewUser = defaultCreateUser,
    ...init
  } = config;
  const provider = createProvider(auth, init);
  return new Elysia({
    name: `@elysiajs/lucia-auth/${name}`,
    seed: config
  }).get(
    path,
    async ({
      cookie: { oauthState, oauthVerifier },
      redirect,
      set
    }) => {
      const [url, verifier, state] = await provider.getAuthorizationUrl();
      oauthVerifier.set({
        value: verifier,
        path: "/",
        sameSite: true,
        httpOnly: true,
        maxAge: 3600
      });
      oauthState.set({
        value: state,
        path: "/",
        sameSite: true,
        httpOnly: true,
        maxAge: 3600
      });
      return redirect(url.toString());
    },
    hook.redirect
  ).get(
    callback,
    async ({
      set,
      query,
      query: { code, state },
      cookie,
      cookie: { oauthState, oauthVerifier }
    }) => {
      if (state !== oauthState.value)
        throw new Error("Invalid state");
      if (state !== oauthVerifier.value)
        throw new Error("Invalid oauth verifier");
      const callback2 = await provider.validateCallback(
        code,
        oauthVerifier.value
      );
      const { getExistingUser, createUser, createKey } = callback2;
      const userData = callback2[`${name}User`];
      const handleCreateUser = async () => {
        const { id, ...attributes } = (
          // @ts-ignore
          await createNewUser(userData)
        );
        await createUser({
          // @ts-ignore
          id,
          attributes
        });
        return {
          userId: id,
          ...attributes
        };
      };
      const user = await getExistingUser() ?? await handleCreateUser();
      if (!user?.userId)
        return set.status = "Internal Server Error";
      const { sessionId } = await auth.createSession({
        userId: user.userId,
        attributes: {}
      });
      cookie[sessionName].value = sessionId;
      oauthState.remove();
      return userData;
    },
    // @ts-ignore
    hook.callback
  );
};
var InvalidSession = class extends Error {
  constructor(message = "Unauthorized") {
    super(message);
    this.message = message;
    this.status = 401;
  }
};

// src/index.ts
var Lucia = (configuration) => {
  const auth = lucia({
    ...configuration,
    env: (process.env.ENV ?? process.env.NODE_ENV) === "production" ? "PROD" : "DEV"
  });
  const name = configuration.name ?? "user";
  const sessionName = configuration.session ?? "session";
  const key = configuration.key ?? "username";
  const {
    maxAge = 60 * 60 * 24 * 30,
    expires = 60 * 60 * 24 * 30,
    sameSite = "none",
    httpOnly = true,
    path = "/",
    ...cookieOptions
  } = configuration.cookie ?? {};
  const elysia = new Elysia2({
    name: "@elysiajs/lucia-auth",
    seed: configuration
  }).error({
    INVALID_SESSION: InvalidSession
  }).derive({ as: "global" }, function deriveAuth({ cookie }) {
    const session = cookie[sessionName];
    const decorators = {
      auth,
      get id() {
        try {
          return auth.getSession(session.value).then(({ user: { userId } }) => userId);
        } catch {
          throw new InvalidSession();
        }
      },
      get profile() {
        return decorators.id.then(
          async (id) => auth.getUser(id)
        );
      },
      async signUp({
        username,
        password,
        ...rest
      }, {
        createSession = false
      } = {
        createSession: false
      }) {
        const data = await auth.createUser({
          key: {
            providerId: key,
            providerUserId: username,
            password
          },
          attributes: {
            username,
            ...rest
          }
        });
        if (createSession)
          await decorators.signIn({
            username,
            password
          });
        return data;
      },
      async signIn(user) {
        const { userId } = await auth.useKey(
          key,
          user.username,
          user.password
        );
        const { sessionId } = await auth.createSession({
          userId,
          attributes: {}
        });
        session.value = sessionId;
        session.set({
          maxAge,
          expires: expires instanceof Date ? expires : new Date(Date.now() + expires * 1e3),
          sameSite,
          httpOnly,
          path,
          ...cookieOptions
        });
      },
      async updateUser(attributes) {
        auth.updateUserAttributes(await decorators.id, attributes);
      },
      async updatePassword(username, password) {
        const { userId } = await auth.updateKeyPassword(
          key,
          username,
          password
        );
        const { sessionId } = await auth.createSession({
          userId,
          attributes: {}
        });
        session.value = sessionId;
      },
      async refresh() {
        const { userId: id, sessionId } = await auth.createSession({
          userId: await decorators.id,
          sessionId: session.value,
          attributes: {}
        });
        session.value = sessionId;
      },
      async signOut(type) {
        if (!type)
          await auth.invalidateSession(session.value);
        else
          switch (type) {
            case "all":
              await auth.invalidateAllUserSessions(
                session.value
              );
              break;
            case "current":
              await auth.invalidateSession(
                session.value
              );
              break;
            case "unused":
              await auth.deleteDeadUserSessions(
                session.value
              );
              break;
          }
        session.remove();
      },
      async delete({
        confirm
      }) {
        await Promise.all([
          auth.deleteUser(await decorators.id),
          auth.invalidateAllUserSessions(session.value)
        ]);
        session.remove();
      },
      async validate() {
        if (!session.value) throw new InvalidSession();
        try {
          await auth.validateSession(session.value);
        } catch {
          throw new InvalidSession();
        }
      }
    };
    return {
      [name]: decorators
    };
  }).macro(({ onBeforeHandle }) => {
    return {
      isSignIn(value) {
        onBeforeHandle(async function checkSession({ cookie }) {
          const session = cookie[sessionName];
          if (!session.value) throw new InvalidSession();
          try {
            await auth.validateSession(session.value);
          } catch {
            throw new InvalidSession();
          }
        });
      }
    };
  });
  return {
    lucia: auth,
    elysia,
    oauth: {
      auth0: createOAuth(
        auth,
        auth0,
        "auth0",
        sessionName,
        ({ email, sub }) => ({
          id: sub,
          username: email
        })
      ),
      apple: createOAuth(
        auth,
        apple,
        "apple",
        sessionName,
        ({ email, sub }) => ({
          id: sub,
          username: email
        })
      ),
      azure: createOAuthWithPKCE(
        auth,
        azureAD,
        "azureAD",
        sessionName,
        ({ email, sub }) => ({
          id: sub,
          username: email
        })
      ),
      box: createOAuth(auth, box, "box", sessionName, ({ id, name: name2 }) => ({
        id,
        username: name2
      })),
      discord: createOAuth(
        auth,
        discord,
        "discord",
        sessionName,
        ({ id, username }) => ({
          id,
          username
        })
      ),
      dropbox: createOAuth(
        auth,
        dropbox,
        "dropbox",
        sessionName,
        ({ email, name: name2 }) => ({
          id: email,
          username: name2
        })
      ),
      facebook: createOAuth(
        auth,
        facebook,
        "facebook",
        sessionName,
        ({ id, name: name2 }) => ({
          id,
          username: name2
        })
      ),
      github: createOAuth(
        auth,
        github,
        "github",
        sessionName,
        ({ id, login }) => ({
          id: id.toString(),
          username: login
        })
      ),
      gitlab: createOAuth(
        auth,
        gitlab,
        "gitlab",
        sessionName,
        ({ id, name: name2 }) => ({
          id: id.toString(),
          username: name2
        })
      ),
      google: createOAuth(
        auth,
        google,
        "google",
        sessionName,
        ({ sub, name: name2 }) => ({
          id: sub,
          username: name2
        })
      ),
      lichless: createOAuthWithPKCE(
        auth,
        lichess,
        "lichess",
        sessionName,
        ({ id, username }) => ({
          id,
          username
        })
      ),
      line: createOAuth(
        auth,
        line,
        "line",
        sessionName,
        ({ userId, displayName }) => ({
          id: userId,
          username: displayName
        })
      ),
      linkedIn: createOAuth(
        auth,
        linkedIn,
        "linkedIn",
        sessionName,
        ({ name: name2, email }) => ({
          id: email,
          username: name2
        })
      ),
      osu: createOAuth(
        auth,
        osu,
        "osu",
        sessionName,
        ({ id, username }) => ({
          id: id.toString(),
          username
        })
      ),
      patreon: createOAuth(
        auth,
        patreon,
        "patreon",
        sessionName,
        ({ id, attributes: { full_name } }) => ({
          id,
          username: full_name
        })
      ),
      reddit: createOAuth(
        auth,
        reddit,
        "reddit",
        sessionName,
        ({ id, name: name2 }) => ({
          id,
          username: name2
        })
      ),
      salesforce: createOAuth(
        auth,
        salesforce,
        "salesforce",
        sessionName,
        ({ user_id, name: name2 }) => ({
          id: user_id,
          username: name2
        })
      ),
      slack: createOAuth(
        auth,
        slack,
        "slack",
        sessionName,
        ({ sub, name: name2 }) => ({
          id: sub,
          username: name2
        })
      ),
      spotify: createOAuth(
        auth,
        spotify,
        "spotify",
        sessionName,
        ({ id, display_name }) => ({
          id,
          username: display_name
        })
      ),
      twitch: createOAuth(
        auth,
        twitch,
        "twitch",
        sessionName,
        ({ id, display_name }) => ({
          id,
          username: display_name
        })
      ),
      twitter: createOAuthWithPKCE(
        auth,
        twitter,
        "twitter",
        sessionName,
        ({ id, name: name2 }) => ({
          id,
          username: name2
        })
      )
    }
  };
};
var src_default = Lucia;
export {
  Lucia,
  src_default as default
};
